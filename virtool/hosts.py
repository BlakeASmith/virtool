import os
import pymongo
import logging
import subprocess

import virtool.job
import virtool.utils
import virtool.files
import virtool.gen
import virtool.database

logger = logging.getLogger(__name__)


class Collection(virtool.database.SyncingCollection):

    """
    The hosts collection class. Provides exposed methods for clients to interact with the hosts database collection.

    :param dispatcher: the dispatcher object that instantiated the viruses Collection object.
    :type dispatcher: :class:`.Dispatcher`

    """

    def __init__(self, dispatch, collections, settings, add_periodic_callback):

        super().__init__("hosts", dispatch, collections, settings, add_periodic_callback)

        self.sync_projector.update({key: True for key in [
            "description",
            "file",
            "added",
            "job"
        ]})

        #: The path from which host FASTA files are imported.
        self.fasta_path = os.path.join(self.settings.get("data_path"), "reference/hosts/fasta")

    @virtool.gen.exposed_method(["add_host"])
    def add(self, transaction):
        """
        Adds a new host described by the transaction. Starts an :class:`.AddHost` job process.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`
        :return: bool indicating success of failure of the request, and a response dict from MongoDB.
        :rtype: tuple

        """
        data = dict(transaction.data)

        job_id = virtool.utils.random_alphanumeric()

        data.update({
            "_id": data.pop("organism"),
            "added": False,
            "username": transaction.connection.user["_id"],
            "job": job_id
        })

        response = yield self.insert(data)

        yield self.dispatcher.collections["jobs"].new(
            "add_host",
            data,
            1,
            4,
            transaction.connection.user["_id"],
            job_id=job_id
        )

        return True, response

    @virtool.gen.exposed_method([])
    def detail(self, transaction):
        """
        Retrieves the entire document from for the host described by the passed host id and returns it to the requesting
        connection.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`
        :returns: bool indicating success of failure of the request, and a dict containing the host detail.
        :rtype: tuple

        """
        detail = yield self.find_one({"_id": transaction.data["_id"]})
        return True, detail

    @virtool.gen.exposed_method(["remove_host"])
    def remove_host(self, transaction):
        """
        Removes the host document and Bowtie2 index files identified in the passed :class:`.Transaction` by calling
        :meth:`._remove_host`. The method :meth:`._remove_host` is for internal use.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :returns: bool indicating success of failure of the request, and a response dict from MongoDB.
        :rtype: tuple

        """
        response = yield self._remove_host(transaction.data["_id"])

        if response:
            return True, response

        return False, dict(message="Host is referenced by one or more samples.")

    @virtool.gen.coroutine
    def _remove_host(self, host_id):
        """
        Removes the host document and Bowtie2 index files identified by the passed host id. The method is for internal
        use while :meth:`.remove_host` is an :ref:`exposed <exposed-methods>` proxy.

        :param host_id: the id of the host to remove
        :type host_id: str

        :returns: the Mongo remove response if the op is successful, otherwise ``None``.
        :rtype: :class:`dict` or ``None``

        """
        # Check how many times the host id is referenced in the samples collection.
        reference_count = yield self.dispatcher.collections["samples"].find({"subtraction": host_id}).count()

        response = None

        # Don't remove the host if it is referenced by a sample.
        if reference_count == 0:
            # Build the host index directory path from the host _id.
            path = os.path.join(
                self.settings.get("data_path"),
                "reference/hosts/index",
                host_id.lower().replace(" ", "_")
            )

            # Remove the host index directory.
            yield virtool.utils.rm(path, recursive=True)

            # Remove the database entry.
            response = yield super().remove(host_id)

        return response

    @virtool.gen.coroutine
    def add_stats(self, data):
        """
        Called by :class:`.AddHost` job processes. Adds stats for the imported sequence set to the host document.

        :param data: dict containing the stat values to add to the host document.
        :type: dict

        """
        self.update(data["_id"], {
            "$set": {
                key: data["stats"][key] for key in ["count", "lengths", "nucleotides"]
            }
        })

    @virtool.gen.coroutine
    def set_added(self, data):
        """
        Class by :class:`.AddHost` job processes. Sets the *added* field to true for the host document identified by the
        passed host id.

        :param data: a dict containing the host id.
        :type data: dict

        """
        yield self.update(data["_id"], {
            "$set": {
                "added": True
            }
        })

    @virtool.gen.coroutine
    def watch(self):
        """
        Returns a list of file describing dicts generated by :func:`.utils.list_files`. FASTA files that are already
        used in host documents are excluded from the files list. Called by a :class:`~.files.Watcher` object.

        :return: a list of file describing dicts
        :rtype: list

        """
        # Get the "file" field for all added hosts. This will be used to exclude already-added files from the
        # generated file listing.
        excluded = yield self.find({}, {"file": True}).distinct("file")

        # Get a list of the host FASTA files minus those already imported to the hosts collection.
        files = yield virtool.utils.list_files(self.fasta_path, excluded)

        return files


class AddHost(virtool.job.Job):

    """
    A subclass of :class:`.Job` that adds a new host to Virtool from a passed FASTA file. Job stages are:

    1. mk_host_dir
    2. stats
    3. bowtie_build
    4. update_db

    """

    def __init__(self, *args, **task_args):
        super(AddHost, self).__init__(*args, **task_args)

        #: The id of the host being added. Extracted from :attr:`~.virtool.job.Job.task_args`.
        self.host_id = self.task_args["_id"]

        #: The path to the FASTA file being added as a host reference.
        self.fasta_path = os.path.join(self.settings["data_path"], "reference/hosts/fasta", self.task_args["file"])

        #: The path to the directory the Bowtie2 index will be written to.
        self.index_path = os.path.join(
            self.settings["data_path"],
            "reference/hosts/index",
            self.host_id.lower().replace(" ", "_")
        )

        #: The job stages.
        self.stage_list = [
            self.mk_host_dir,
            self.stats,
            self.bowtie_build,
            self.snap_build,
            self.update_db
        ]

    def mk_host_dir(self):
        """
        Make a directory for the host index files at ``<vt_data_path>/reference/hosts/index/<host_id>``.

        """
        os.mkdir(self.index_path)

    def stats(self):
        """
        Generate some stats for the FASTA file associated with this job. These numbers include nucleotide distribution,
        length distribution, and sequence count.

        """
        nucleotides = {
            "a": 0,
            "t": 0,
            "g": 0,
            "c": 0,
            "n": 0
        }

        count = 0
        length_list = []
        sequence = []

        # Go through the fasta file getting the nucleotide counts, lengths, and number of sequences
        with open(self.fasta_path, "r") as fasta_file:
            for line in fasta_file:
                if line[0] == ">":
                    count += 1

                    if sequence:
                        sequence = "".join(sequence)
                        length_list.append(len(sequence))

                        for i in ["a", "t", "g", "c", "n"]:
                            # Find lowercase and uppercase nucleotide characters
                            nucleotides[i] += sequence.count(i)
                            nucleotides[i] += sequence.count(i.upper())

                        sequence = []

                else:
                    sequence.append(line.rstrip())

        # Calculate the average and total length to be returned at end of function
        lengths = {
            "total": sum(length_list),
            "mean": round(sum(length_list) / len(length_list)),
            "max": max(length_list),
            "min": min(length_list)
        }

        # Reprocess the nucleotides dict to contain ratios for each nucleotide rather than counts
        nucleotides = {i: round(nucleotides[i] / lengths["total"], 3) for i in nucleotides}

        self.collection_operation("hosts", "add_stats", {"_id": self.host_id, "stats": {
            "nucleotides": nucleotides,
            "lengths": lengths,
            "count": count
        }})

    def bowtie_build(self):
        """
        Call *bowtie2-build* using :meth:`~.Job.run_process` to build a Bowtie2 index for the host.

        """
        command = [
            "bowtie2-build",
            "-f",
            self.fasta_path,
            self.index_path + "/reference"
        ]

        self.run_process(command)

    def snap_build(self):
        command = [
            "snap",
            "index",
            self.fasta_path,
            self.index_path,
            "-t" + str(self.proc)
        ]

        self.run_process(command, no_output_failure=True)

    def update_db(self):
        """
        Set the *added* field to True by calling :meth:`.hosts.Collection.set_added`.

        """
        self.collection_operation("hosts", "set_added", {"_id": self.host_id})

    def cleanup(self):
        """
        Clean up if the job process encounters an error or is cancelled. Removes the host document from the database.

        """
        self.collection_operation("hosts", "_remove_host", self.host_id)


def get_bowtie2_index_names(index_path):
    """
    Returns a list of sequence ids used to generate the Bowtie2 index located at ``index_path``.

    :param index_path: the path of the Bowtie2 index to inspect.
    :type index_path: str

    :return: a list of sequence id strings.
    :rtype: list
    """
    try:
        inspect = subprocess.check_output(["bowtie2-inspect", "-n", index_path], stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError:
        return None

    inspect_list = str(inspect, "utf-8").split("\n")
    inspect_list.remove("")

    return inspect_list


def check_collection(db_name, data_path, host="localhost", port=27017):
    db = pymongo.MongoClient(host, port)[db_name]

    response = {
        "orphaned": list(),
        "missing": list(),
        "mismatched": list()
    }

    db_hosts = db.hosts.find({}, {"count": True, "file": True})

    index_path = os.path.join(data_path, "reference/hosts/index")

    for host in db_hosts:
        index_ref_count = len(get_bowtie2_index_names(os.path.join(
            index_path,
            host["_id"].lower().replace(" ", "_"),
            "reference"
        )))

        if index_ref_count is None:
            response["missing"].append(host["_id"])

        elif index_ref_count != host["count"]:
            response["mismatched"].append(host["_id"])

    response["failed"] = response["missing"] or response["mismatched"]

    return response
