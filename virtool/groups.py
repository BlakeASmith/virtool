import logging
import pymongo.errors

import virtool.gen
import virtool.utils
import virtool.database

from virtool.permissions import PERMISSIONS

logger = logging.getLogger(__name__)


class Collection(virtool.database.Collection):

    """
    An interface for the *groups* collection in MongoDB. Manages user groups and their permissions.

    :param dispatcher: the :class:`.Dispatcher` object that instantiated the collection.
    :type dispatcher: :class:`.Dispatcher`

    """

    def __init__(self, dispatch, collections, settings, add_periodic_callback):

        super().__init__("groups", dispatch, collections, settings, add_periodic_callback)

        # Get the group id and permissions for sync. Permissions is the only field in the group document.
        self.sync_projector.append("permissions")

    @virtool.gen.exposed_method(["modify_options"])
    def add(self, transaction):
        """
        Adds a new user group based on the data passed from the client. The document id is the same as the group's
        display name. No permissions are initially granted the user. Permissions must be modified after group creation
        by calling :meth:`.update_permissions`.

        :param transaction: the transaction associated with the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating success or failure and a response from the MongoDB insert operation
        :rtype: tuple

        """
        try:
            response = yield self.insert({
                "_id": transaction.data["_id"],
                "permissions": {permission: False for permission in PERMISSIONS}  # All permissions are initially False.
            })

            return True, response

        except pymongo.errors.DuplicateKeyError:
            return False, dict(message="Group name already exists.")

    @virtool.gen.exposed_method(["modify_options"])
    def update_permissions(self, transaction):
        """
        Updates the permissions of the group identified by the passed group id. Permissions are modified using the
        :class:`dict` of permissions passed in the transaction.

        The method :meth:`.users.Collection.update_user_permissions` is called for all users that belong to the group.

        :param transaction: the transaction associated with the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating the request's success and a response from the MongoDB insert operation.
        :rtype: tuple

        """
        data = transaction.data

        # Get the current permissions dict for the passed group id.
        group_permissions = yield self.get_field(data["_id"], "permissions")

        # Update the current permissions with those passed from the client.
        group_permissions.update(data["permissions"])

        # Update the group permissions in the database with the updated dict.
        response = yield self.update(data["_id"], {
            "$set": {
                "permissions": group_permissions
            }
        })

        yield self.update_member_users(data["_id"])

        return True, response

    @virtool.gen.exposed_method(["modify_options"])
    def remove_group(self, transaction):
        """
        Remove the group identified by the group id passed in the transaction.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: the response from the MongoDB remove operation.
        :rtype: tuple

        """
        group_id = transaction.data["_id"]

        # Check if the user has permission to remove users.
        # Only accept single id strings.
        if not isinstance(group_id, str):
            return False, dict(message="Only one user group can be removed per call.")

        # The administrator is not permitted to be removed.
        if group_id == "administrator":
            logger.warning("User {} attempted to remove administrator group".format(
                transaction.connection.user["_id"]
            ))
            return False, dict(message="Administrator group cannot be removed.")

        group_count = yield self.find({"_id": group_id}).count()

        if group_count == 0:
            logger.warning("User {} attempted to remove non-existent group {}".format(
                transaction.connection.user["_id"],
                group_id
            ))

            return False, dict(message="Group {} does not exist.")

        yield self.update_member_users(group_id, remove=True)

        response = yield super().remove([group_id])

        return True, response

    @virtool.gen.coroutine
    def update_member_users(self, group_id, remove=False):
        groups = yield self.collections["groups"].find().to_list(length=None)

        member_users = yield self.collections["users"].find({"groups": group_id}).to_list(None)

        for user in member_users:
            if remove:
                user["groups"].pop(group_id)

            new_permissions = merge_group_permissions([group for group in groups if group["_id"] in user["groups"]])

            # Skip updating this user if their group membership and permissions haven't changed.
            if not remove and new_permissions == user["permissions"]:
                continue

            update_dict = {
                "$set": {
                    "permissions": new_permissions
                }
            }

            if remove:
                update_dict["$pull"] = {
                    "groups": group_id
                }

            yield self.collections["users"].db.update(user["_id"], update_dict)

    @virtool.gen.coroutine
    def get_member_users(self, group_id):
        member_user_ids = yield self.collections["users"].find({"groups": group_id}).distinct("_id")
        return member_user_ids


def merge_group_permissions(groups):
    """
    Return a :class:`dict` of permissions that will be inherited by a user belonging to all the passed ``groups``.

    :param groups: a list of group documents.
    :return: a dict keyed by permission names with boolean values indicating the state of the permission

    """
    permission_dict = {permission_name: False for permission_name in virtool.groups.PERMISSIONS}

    for permission_name in PERMISSIONS:
        for group in groups:
            if group["permissions"][permission_name]:
                permission_dict[permission_name] = True

    return permission_dict
