import logging
import pymongo.errors

import virtool.gen
import virtool.utils
import virtool.database
from virtool.permissions import PERMISSIONS

logger = logging.getLogger(__name__)


class Collection(virtool.database.SyncingCollection):

    """
    An interface for the *groups* collection in MongoDB. Manages user groups and their permissions.

    :param dispatcher: the :class:`.Dispatcher` object that instantiated the collection.
    :type dispatcher: :class:`.Dispatcher`

    """

    def __init__(self, dispatcher):

        super().__init__("groups", dispatcher)

        # Get the group id and permissions for sync. Permissions is the only field in the group document.
        self.sync_projector.update({
            "permissions": True
        })

    @virtool.gen.exposed_method(["modify_options"])
    def add(self, transaction):
        """
        Adds a new user group based on the data passed from the client. The document id is the same as the group's
        display name. No permissions are initially granted the user. Permissions must be modified after group creation
        by calling :meth:`.update_permissions`.

        :param transaction: the transaction associated with the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating success or failure and a response from the MongoDB insert operation
        :rtype: tuple

        """
        try:
            response = yield self.insert({
                "_id": transaction.data["_id"],
                "permissions": {permission: False for permission in PERMISSIONS}  # All permissions are initially False.
            })

            return True, response

        except pymongo.errors.DuplicateKeyError:
            return False, dict(message="Group name already exists.")

    @virtool.gen.exposed_method(["modify_options"])
    def update_permissions(self, transaction):
        """
        Updates the permissions of the group identified by the passed group id. Permissions are modified using the
        :class:`dict` of permissions passed in the transaction.

        The method :meth:`.users.Collection.update_user_permissions` is called for all users that belong to the group.

        :param transaction: the transaction associated with the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating the request's success and a response from the MongoDB insert operation.
        :rtype: tuple

        """
        data = transaction.data

        # Get the current permissions dict for the passed group id.
        group_permissions = yield self.get_field(data["_id"], "permissions")

        # Update the current permissions with those passed from the client.
        group_permissions.update(data["permissions"])

        # Update the group permissions in the database with the updated dict.
        response = yield self.update(data["_id"], {
            "$set": {
                "permissions": group_permissions
            }
        })

        # Get a list of user ids of users affected by the change.
        affected_user_ids = yield self.get_member_users(data["_id"])

        # Make a list of affected user ids and call update_user_groups to update the user entries.
        yield self.dispatcher.collections["users"].update_user_permissions(affected_user_ids)

        return True, response

    @virtool.gen.exposed_method(["modify_options"])
    def remove_group(self, transaction):
        """
        Remove the group identified by the group id passed in the transaction.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: the response from the MongoDB remove operation.
        :rtype: tuple

        """
        group_id = transaction.data["_id"]

        # Check if the user has permission to remove users.
        # Only accept single id strings.
        if isinstance(group_id, str):
            # The administrator is not permitted to be removed.
            if group_id != "administrator":
                affected_user_ids = yield self.get_member_users(group_id)

                yield self.dispatcher.collections["users"].db.update({"_id": {"$in": affected_user_ids}}, {
                    "$pull": {
                        "groups": group_id
                    }
                })

                yield self.dispatcher.collections["users"].update_user_permissions(affected_user_ids)

                response = yield super().remove([group_id])

                return True, response

            logger.warning("User {} attempted to remove administrator group".format(
                transaction.connection.user["_id"]
            ))

            return False, dict(message="Administrator group cannot be removed.")

        # Send an error message to the client in a transaction if the provided user id is not a single string.
        else:
            return False, dict(message="Only one user group can be removed per call.")

    @virtool.gen.coroutine
    def get_member_users(self, group_id):
        member_user_ids = yield self.dispatcher.collections["users"].find(
            {"groups": group_id},
            {"_id": True}
        ).distinct("_id")

        return member_user_ids
