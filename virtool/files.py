import os
import datetime

import tornado.websocket

import virtool.gen
import virtool.utils


class Manager:

    """
    All files being uploaded or downloaded are stored in a database collection with the time they are created. Files are
    only retained for twenty minutes before being deleted. Documents in the collection contain the following fields:

    * **file_id** - a unique id for the file; an ObjectID generated by MongoDB when the file document is first inserted
      into the collection

    * **name** - the name used to register the file; the name of the uploaded file or the name the file should take when
      downloaded

    * **content_type** - the format used in the file (eg. JSON, HTML)

    * **download** - boolean indicating whether the file is a download (False when the file is an upload)

    :param server: the server object that created the :any:`Manager` object.

    """

    def __init__(self, server):
        self.settings = server.settings

        if self.settings.get("server_ready"):
            # Create dict containing paths for uploads and downloads keyed by 'upload' and 'download'.
            self.paths = {suffix: os.path.join(self.settings.get("data_path"), suffix) for suffix in [
                'upload', 'download'
            ]}

        #: A MotorCollection object.
        self.db = virtool.utils.get_db_client(self.settings)

        # Check the registered files every thirty seconds.
        server.add_periodic_callback(self.iterate, 20000)

    @virtool.gen.coroutine
    def register(self, name, body, content_type=None, download=True):
        """
        Registers a file in the file manager. A unique ``file_id`` is generated for the file. Using :meth:`.write_file`
        , the data in the ``content`` parameter is written to a file of name ``file_id`` in the appropriate download or
        upload directory. The passed ``name`` and ``content_type`` are stored in the database.

        :param name: the name of an uploaded file or the name for the file should it be downloaded.
        :type name: str
        :param body: the content to store in the file.
        :type body: str
        :param content_type: what type of content is in the file (eg. JSON).
        :type content_type: str
        :param download: indicates if the file is a download (``True``) or upload (``False``).
        :type download: bool
        :return: a unique file id.
        :rtype: str

        """
        file_id = yield self.db.files.insert({
            "name": name,
            "content_type": content_type,
            "download": download,
            "expires": datetime.datetime.now() + datetime.timedelta(minutes=20)
        })

        file_id = str(file_id)

        yield self.write_file(file_id, body, download)

        return file_id

    @virtool.gen.coroutine
    def iterate(self):
        """
        A coroutine that is called every 30 seconds after the :any:`Manager` object is created. Gets all of the
        managed files from the database and calls :meth:`.remove_file` on files older than 20 minutes and removes
        their database documents.

        """
        cursor = self.db.files.find()

        to_remove = list()

        while (yield cursor.fetch_next):

            document = cursor.next_object()

            if document["expires"] < datetime.datetime.now():
                yield self.remove_file(document["_id"], document["download"])
                to_remove.append(document["_id"])

        yield self.db.files.remove({"_id": {"$in": to_remove}})

    @virtool.gen.synchronous
    def write_file(self, file_id, body, download):
        """
        Writes a file to the upload or download directory.

        :param file_id: unique id for the file.
        :type file_id: string

        :param body: the content to write to the file.
        :type body: any

        :param download: whether the file is a download or upload.
        :type download: bool

        """
        # Determine the path to which the file should be written.
        path = os.path.join(self.paths["download" if download else "upload"], file_id)

        with open(path, "wb") as handle:
            handle.write(body)

    @virtool.gen.synchronous
    def remove_file(self, file_id, download):
        """
        Removes a file from the database collection and from the appropriate directory.

        :param file_id: the id of the file to remove.
        :type file_id: str

        :param download: boolean indicating if file is a download (False if upload).
        :type download: bool

        :return: boolean indicating whether a file was removed or not.
        :rtype: bool

        """
        try:
            path = os.path.join(self.paths["download" if download else "upload"], str(file_id))
            yield virtool.utils.rm(path)
        except FileNotFoundError:
            return False

        return True


class Watcher:

    """
    Watches directories by periodically calling functions registered using :meth:`.register`. Each function is
    identified by a *name* string. Changes in the file list are sent to listening connections
    (:class:`.web.SocketHandler` objects) in the list in :attr:`~.Watcher.listeners`

    :param dispatcher: the dispatcher that instantiated the watcher object.
    :type dispatcher: :class:`~.dispatcher.Dispatcher`

    """
    def __init__(self, dispatcher):
        self.dispatcher = dispatcher

        #: A :class:`dict`. Keys are *names*. Values are functions that return lists generated by
        #: :func:`.utils.list_files.
        #: of a directory.
        self.watch_functions = dict()

        #: A :class:`dict` containing lists of :class:`.web.SocketHandler` objects listening to changes from the watch
        #: function. Keys are *names*.
        self.listeners = dict()

        #: A :class:`dict` containing lists keyed by a watcher *name*. \
        self.files = dict()

        self.dispatcher.server.add_periodic_callback(self.run)

    def register(self, name, func):
        """
        Registers a function (``func``) that returns a list of files :func:`.utils.list_files` in a directory defined in
        ``func``. Periodic calls to ``func`` will be used to check if the directory's contents have changed. Any changes
        will be dispatched to :class:`.SocketHandler` objects stored in :attr:`.listeners`.

        :param name:
        :type name: str

        :param func: a function to call periodically that returns a list of files generated by :func:`.utils.list_files`
        :type func: function

        """
        self.files[name] = dict()
        self.listeners[name] = list()
        self.watch_functions[name] = func

    def add_listener(self, name, connection):
        """
        Add a listening :class:`.SocketHandler` object that should receive file changes dispatches for the given
        ``name``.

        :param name: the name of the watch function to register the listener under.
        :type name: str

        :param connection: the listening connection to register.
        :type connection: :class:`~web.SocketHandler`

        """
        try:
            self.listeners[name].append(connection)
        except KeyError:
            raise KeyError("No watch function registered with the name: " + str(name))

    def remove_listener(self, connection, name=None):
        """
        Remove listening :class:`.SocketHandler` that should no longer receive file change dispatches generated by the
        watch function with the passed ``name``.

        :param name: the name of the watch function to register the listener under.
        :type name: str

        :param connection: the listening connection to register.
        :type connection: :class:`~web.SocketHandler`

        """
        try:
            if name:
                self.listeners[name].remove(connection)
            else:
                for name in self.listeners:
                    self.listeners[name].remove(connection)
        except KeyError:
            raise KeyError("No watch function registered with the name: " + str(name))
        except ValueError:
            # Fail silently if the connection is not actually in the listeners list.
            pass

    @virtool.gen.coroutine
    def run(self):
        """
        Call all watch functions registered in :attr:`.Watcher.files`. Dispatch all file changes to the appropriate
        connections. Called every 500 ms once the :class:`.Watcher` object is instantiated.

        """
        for name in self.watch_functions:
            if len(self.listeners[name]) > 0:
                new = yield self.watch_functions[name]()

                if new != self.files[name]:
                    for file_name, file_document in new.items():
                        if file_name not in self.files[name] or file_document != self.files[name][file_name]:
                            # Dispatch an "add" operation if the file is new.
                            for listener in list(self.listeners[name]):
                                try:
                                    self.dispatcher.dispatch({
                                        "operation": "update",
                                        "collection_name": name,
                                        "data": file_document
                                    }, [listener])
                                except tornado.websocket.WebSocketClosedError:
                                    self.listeners[name].remove(listener)

                    for file_name, file_document in self.files[name].items():
                        if file_name not in new:
                            # Dispatch a "remove" operation if the file name is in the old file list but not the new
                            # one.
                            for listener in list(self.listeners[name]):
                                try:
                                    self.dispatcher.dispatch({
                                        "operation": "remove",
                                        "collection_name": name,
                                        "data": [file_name]
                                    }, [listener])
                                except tornado.websocket.WebSocketClosedError:
                                    self.listeners[name].remove(listener)

                    self.files[name] = new