import os
import datetime

import tornado.websocket

import virtool.gen
import virtool.utils
import virtool.database


class Manager:

    """
    All files being uploaded or downloaded are stored in a database collection with the time they are created. Files are
    only retained for twenty minutes before being deleted. Documents in the collection contain the following fields:

    * **file_id** - a unique id for the file; an ObjectID generated by MongoDB when the file document is first inserted
      into the collection

    * **name** - the name used to register the file; the name of the uploaded file or the name the file should take when
      downloaded

    * **content_type** - the format used in the file (eg. JSON, HTML)

    * **download** - boolean indicating whether the file is a download (False when the file is an upload)

    :param add_periodic_callback: takes a function and adds it to the IOLoop to be called periodically.
    :type add_periodic_callback: func

    """
    def __init__(self, db, data_path, add_periodic_callback):

        self.db = db

        # Create dict containing paths for uploads and downloads keyed by 'upload' and 'download'.
        self.paths = {suffix: os.path.join(data_path, suffix) for suffix in [
            "upload", "download"
        ]}

        # Check the registered files every thirty seconds.
        add_periodic_callback(self.iterate, 20000)

    @virtool.gen.coroutine
    def iterate(self):
        """
        A coroutine that is called every 30 seconds after the :any:`Manager` object is created. Gets all of the
        managed files from the database and calls :meth:`.remove_file` on files older than 20 minutes and removes
        their database documents.

        """
        cursor = self.db.files.find()

        to_remove = list()

        while (yield cursor.fetch_next):
            document = cursor.next_object()

            if document["expires"] < datetime.datetime.now():
                to_remove.append(document)

        yield self.remove(to_remove)

    @virtool.gen.coroutine
    def register(self, name, body, now=datetime.datetime.now(), expiry=1200, content_type=None, download=True):
        """
        Registers a file in the file manager. A unique ``file_id`` is generated for the file. Using :meth:`.write_file`
        , the data in the ``content`` parameter is written to a file of name ``file_id`` in the appropriate download or
        upload directory. The passed ``name`` and ``content_type`` are stored in the database.

        :param name: the name of an uploaded file or the name for the file should it be downloaded.
        :type name: str

        :param body: the content to store in the file.
        :type body: str

        :param now: a datetime object to attach to the database document.
        :type now: func

        :param expiry: the number of seconds the file should be kept before it is automatically deleted
        :type expiry: int

        :param content_type: what type of content is in the file (eg. JSON).
        :type content_type: str

        :param download: indicates if the file is a download (``True``) or upload (``False``).
        :type download: bool

        :return: a unique file id.
        :rtype: str

        """
        file_id = yield virtool.utils.get_new_document_id(self.db.files)

        yield self.db.files.insert({
            "_id": file_id,
            "name": name,
            "content_type": content_type,
            "download": download,
            "expires": now + datetime.timedelta(seconds=expiry)
        })

        file_id = str(file_id)

        path = os.path.join(self.paths["download" if download else "upload"], file_id)

        yield virtool.utils.write_file(path, body, is_bytes=True)

        return file_id

    @virtool.gen.synchronous
    def remove(self, to_remove):
        """
        Removes a file from the database collection and from the appropriate directory.

        """
        virtool.database.coerce_list(to_remove)

        for document in to_remove:
            path = os.path.join(self.paths["download" if document["download"] else "upload"], document["_id"])

            yield virtool.utils.rm(path)

            yield self.db.files.remove({
                "_id": {
                    "$in": [document["_id"] for document in to_remove]
                }
            })


class Watcher:

    """
    Watches directories by periodically calling functions registered using :meth:`.register`. Each function is
    identified by a *name* string. Changes in the file list are sent to listening connections
    (:class:`.web.SocketHandler` objects) in the list in :attr:`~.Watcher.listeners`

    :param dispatch: dispatches a message via the dispatcher.
    :type dispatch: func

    :param add_periodic_callback: takes a function and adds it to the IOLoop to be called periodically.
    :type add_periodic_callback: func

    """
    def __init__(self, dispatch, add_periodic_callback):

        self.dispatch = dispatch

        #: A :class:`dict`. Keys are *names*. Values are functions that return lists generated by
        #: :func:`.utils.list_files.
        #: of a directory.
        self.watch_functions = dict()

        #: A :class:`dict` containing lists of :class:`.web.SocketHandler` objects listening to changes from the watch
        #: function. Keys are *names*.
        self.listeners = dict()

        #: A :class:`dict` containing lists keyed by a watcher *name*.
        self.files = dict()

        add_periodic_callback(self.run)

    def register(self, name, func):
        """
        Registers a function (``func``) that returns a list of files :func:`.utils.list_files` in a directory defined in
        ``func``. Periodic calls to ``func`` will be used to check if the directory's contents have changed. Any changes
        will be dispatched to :class:`.SocketHandler` objects stored in :attr:`.listeners`.

        :param name:
        :type name: str

        :param func: a function to call periodically that returns a list of files generated by :func:`.utils.list_files`
        :type func: function

        """
        self.files[name] = dict()
        self.listeners[name] = list()
        self.watch_functions[name] = func

    def add_listener(self, name, connection):
        """
        Add a listening :class:`.SocketHandler` object that should receive file changes dispatches for the given
        ``name``.

        :param name: the name of the watch function to register the listener under.
        :type name: str

        :param connection: the listening connection to register.
        :type connection: :class:`~web.SocketHandler`

        """
        try:
            self.listeners[name].append(connection)
        except KeyError:
            raise KeyError("No watch function registered with the name: " + str(name))

    def remove_listener(self, connection, name=None):
        """
        Remove listening :class:`.SocketHandler` that should no longer receive file change dispatches generated by the
        watch function with the passed ``name``.

        :param name: the name of the watch function to register the listener under.
        :type name: str

        :param connection: the listening connection to register.
        :type connection: :class:`~web.SocketHandler`

        """
        try:
            if name:
                self.listeners[name].remove(connection)
            else:
                for name in self.listeners:
                    self.listeners[name].remove(connection)
        except KeyError:
            raise KeyError("No watch function registered with the name: " + str(name))
        except ValueError:
            # Fail silently if the connection is not actually in the listeners list.
            pass

    @virtool.gen.coroutine
    def run(self):
        """
        Call all watch functions registered in :attr:`.Watcher.files`. Dispatch all file changes to the appropriate
        connections. Called every 500 ms once the :class:`.Watcher` object is instantiated.

        """
        for name in self.watch_functions:
            if len(self.listeners[name]) > 0:
                new = yield self.watch_functions[name]()

                if new != self.files[name]:
                    for file_name, file_document in new.items():
                        if file_name not in self.files[name] or file_document != self.files[name][file_name]:
                            # Dispatch an "add" operation if the file is new.
                            for listener in list(self.listeners[name]):
                                try:
                                    self.dispatch({
                                        "operation": "update",
                                        "collection_name": name,
                                        "data": file_document
                                    }, [listener])
                                except tornado.websocket.WebSocketClosedError:
                                    self.listeners[name].remove(listener)

                    for file_name, file_document in self.files[name].items():
                        if file_name not in new:
                            # Dispatch a "remove" operation if the file name is in the old file list but not the new
                            # one.
                            for listener in list(self.listeners[name]):
                                try:
                                    self.dispatch({
                                        "operation": "remove",
                                        "collection_name": name,
                                        "data": [file_name]
                                    }, [listener])
                                except tornado.websocket.WebSocketClosedError:
                                    self.listeners[name].remove(listener)

                    self.files[name] = new
