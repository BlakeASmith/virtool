import os
import virtool.database

from pymongo import ReturnDocument
from virtool.utils import rm


PATHOSCOPE_TASK_NAMES = ["pathoscope_bowtie", "pathoscope_snap"]


projector = [
    "_id",
    "_version",
    "name",
    "added",
    "username",
    "imported",
    "archived",
    "pathoscope",
    "nuvs",
    "group",
    "group_read",
    "group_write",
    "all_read",
    "all_write"
]


async def processor(documents):
    """
    Redefined from superclass to prevent syncing of documents for which the requesting connection doesn't have read
    rights.

    :param documents: the documents to process
    :type documents: list

    :return: the processed documents
    :rtype: list

    """
    documents = virtool.database.coerce_list(documents)

    to_send = list()

    user = None

    for document in documents:

        send = user is None or (
            document["group"] == "none" or document["all_read"] or user["_id"] == document["username"] or
            document["group"] in user["groups"] or "administrator" in user["groups"]
        )

        if send:
            to_send.append(document)

    return to_send


def calculate_algorithm_tags(analyses):
    update = {
        "pathoscope": False,
        "nuvs": False
    }

    pathoscope = list()
    nuvs = list()

    for analysis in analyses:
        if analysis["algorithm"] in PATHOSCOPE_TASK_NAMES:
            pathoscope.append(analysis)

        if analysis["algorithm"] == "nuvs":
            nuvs.append(analysis)

    if len(pathoscope) > 0:
        update["pathoscope"] = any([document["ready"] for document in pathoscope]) or "ip"

    if len(nuvs) > 0:
        update["nuvs"] = any([document["ready"] for document in nuvs]) or "ip"

    return update


async def recalculate_algorithm_tags(db, sample_id):
    analyses = await db.analyses.find({"sample_id": sample_id}, ["ready", "algorithm"]).to_list(None)

    update = calculate_algorithm_tags(analyses)

    await db.samples.update({"_id": sample_id}, {"$set": update})


async def get_sample_owner(db, sample_id):
    return (await db.users.find_one(sample_id, "user_id"))["user_id"]


async def set_quality(db, sample_id, quality):
    """
    Populates the ``quality`` field of the document with data generated by FastQC. Data includes GC content, read
    length ranges, and detailed quality data. Also sets the ``imported`` field to ``True``.

    Called from an :class:`.ImportReads` job.

    :param db: a Motor client
    :type db: :class:`.motor.motor_asyncio.AsyncIOMotorClient``
    
    :param sample_id: the id of the sample to set quality for
    :type sample_id: str
    
    :param quality: the quality data to attach to the sample document
    :type quality: dict

    """
    document = await db.samples.find_one_and_update(sample_id, {
        "$set": {
            "quality": quality,
            "imported": True
        }
    }, return_document=ReturnDocument.AFTER)

    return document


async def set_analysis(db, sample_id, analysis_id, analysis_data):
    """
    Update the analysis document identified using ``data``, which contains the analysis id and the update. Sets the
    analysis' ``ready`` field to ``True``. Sets the parent sample's ``analyzed`` field to ``True`` and increments
    its version by one.

    """
    document = await db.analyses.find_one({"_id": analysis_id})
    document.update(analysis_data)
    document["ready"] = True

    await db.analyses.update({"_id": analysis_id}, {"$set": document})

    await db.samples.update(sample_id, {
        "$inc": {"_version": 1},
        "$set": {"analyzed": True}
    })


async def remove_samples(db, settings, id_list):
    """
    Complete removes the samples identified by the document ids in ``id_list``. In order, it:

    - removes all analyses associated with the sample from the analyses collection
    - removes the sample from the samples collection
    - removes the sample directory from the file system
    
    :param db: a Motor client
    :type db: :class:`.motor.motor_asyncio.AsyncIOMotorClient``
    
    :param settings: a Virtool settings object
    :type settings: :class:`.Settings`

    :param id_list: a list sample ids to remove
    :type id_list: list

    :return: the response from the samples collection remove operation
    :rtype: dict

    """
    # Remove all analysis documents associated with the sample.
    db.analyses.remove({"_id": {
        "$in": id_list
    }})

    # Remove the samples described by id_list from the database.
    result = await db.samples.remove({"_id": {
        "$in": id_list
    }})

    samples_path = os.path.join(settings.get("data_path"), "samples")

    for sample_id in id_list:
        try:
            await rm(os.path.join(samples_path, "sample_" + sample_id), recursive=True)
        except FileNotFoundError:
            pass

    return result
