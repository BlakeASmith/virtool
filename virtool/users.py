import hashlib
import logging

import virtool.gen
import virtool.database
import virtool.utils
import virtool.groups

logger = logging.getLogger(__name__)


USER_SETTINGS = {
    "show_ids": False,
    "show_versions": False,
    "quick_analyze_algorithm": None,
    "skip_quick_analyze_dialog": False
}


class Collection(virtool.database.Collection):
    """
    Provides an interface to the users MongoDB collection. During initialisation of the object, permissions are
    reconciled for all users and all user documents are updated to contain required fields if they are missing.

    """
    def __init__(self, dispatch, collections, settings, add_periodic_callback):
        super().__init__("users", dispatch, collections, settings, add_periodic_callback)

        self.sync_projector += [
            "groups",
            "sessions",
            "force_reset",
            "last_password_change",
            "permissions",
            "settings",
            "primary_group"
        ]

    @virtool.gen.coroutine
    def update(self, query, update, increment_version=True, upsert=False, connections=None):
        """
        A redefinition of :meth:`.database.Collection.update` that dispatches an ``amend`` operation with a copy of the
        entire new user document to connections owned by the modified users. The user dict referenced by
        :attr:`.SocketHandler.user` is also updated so permissions can be checked on the server side.

        :param query: query dictionary or single document id to be passed to MongoDB as a query.
        :type query: str or dict

        :param update: the update that will be passed to MongoDB.
        :type update: dict

        :param increment_version: when ``True``, the _version field is incremented by 1.
        :type increment_version: bool

        :param upsert: perform an upsert when set to True.
        :type upsert: bool

        :param connections: a list of :class:`~.web.SocketHandler` objects to dispatch the update to. If no list is
                            supplied, the update with be dispatched to all connected clients.
        :type connections: list or None

        :return: the MongoDB response object amended with the modified document ids.
        :rtype: dict

        """
        response = yield super().update(query, update, increment_version, upsert)

        projection = [
            "_id",
            "groups",
            "last_password_change",
            "primary_group",
            "permissions",
            "settings",
        ]

        users = yield self.find({"_id": {
            "$in": response["_ids"]
        }}, projection).to_list(None)

        for user in users:
            yield self.dispatch(
                "amend",
                user,
                interface="user",
                conn_filter=lambda conn: conn.user["_id"] == user["_id"],
                conn_modifier=lambda conn: conn.user.update(user)
            )

        return response

    @virtool.gen.exposed_method(["modify_options"])
    def set_group(self, transaction):
        """
        Toggle membership for the user identified by the passed user id in the group with the passed group id.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating success and the responses from calling :meth:`.update_user_permissions`.
        :rtype: tuple

        """
        user_id = transaction.data["user_id"]
        group_id = transaction.data["group_id"]

        data = transaction.data

        user_exists = yield self.user_exists(user_id)

        if not user_exists:
            return False, dict(message="User does not exist")

        all_group_ids = yield self.collections["groups"].distinct("_id")
        member_group_ids = yield self.distinct("groups", {"_id": user_id})

        if group_id == "administrator" and user_id == transaction.connection.user["_id"]:
            return False, dict(message="Administrators cannot remove themselves from the administrator group")

        if group_id not in all_group_ids:
            return False, dict(message="Group does not exist")

        if group_id in member_group_ids:
            member_group_ids.remove(data["group_id"])
        else:
            member_group_ids.append(data["group_id"])

        groups = yield self.collections["groups"].find({"_id": {
            "$in": member_group_ids
        }}).to_list(None)

        new_permissions = virtool.groups.merge_group_permissions(list(groups))

        response = yield self.update(data["user_id"], {
            "$set": {
                "permissions": new_permissions,
                "groups": member_group_ids
            }
        })

        return True, response

    @virtool.gen.exposed_method(["modify_options"])
    def set_primary_group(self, transaction):
        """
        Sets the group with the passed group id as the primary group of the user identified by the passed user id.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating success and the response from the Mongo update operation.
        :rtype: tuple

        """
        user_id = transaction.data["_id"]
        group_id = transaction.data["group_id"]

        user_exists = yield self.user_exists(user_id)

        if not user_exists:
            return False, dict(message="User does not exist")

        group_ids = yield self.collections["groups"].distinct("_id")

        if group_id not in group_ids:
            return False, dict(message="Group does not exist")

        response = yield self.update(user_id, {"$set": {
            "primary_group": group_id
        }})

        return True, response

    @virtool.gen.exposed_method([])
    def change_user_setting(self, transaction):
        """
        Change the user settings identified by the ``key`` passed in the transaction to the ``value`` passed in the
        transaction.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating success and an error message or the response from the Mongo update operation
        :rtype: tuple

        """
        data = transaction.data

        if data["key"] not in USER_SETTINGS:
            return False, dict(message="Unknown user setting {}".format(data["key"]))

        response = yield self.update(transaction.connection.user["_id"], {"$set": {
            "settings.{}".format(data["key"]): data["value"]
        }}, transaction)

        return True, response

    @virtool.gen.exposed_method(["modify_options"])
    def add(self, transaction):
        """
        Add a new user to the user database. The transaction should pass a new username (_id), a password, and the key
        ``force_reset`` set to ``True`` or ``False``. Setting ``force_reset`` will make the user reset their password
        the first time they login.

        The transaction will not succeed if the user id already exists.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating success and either an error message or the Mongo insert response.
        :rtype: tuple

        """
        data = transaction.data

        # Check if the username is already taken. Fail if it does.
        user_exists = yield self.user_exists(data["_id"])

        if user_exists:
            return False, dict(message="User already exists.")

        salt, password = salt_hash(data["password"])

        new_user = {
            "_id": data["_id"],
            # A list of group _ids the user is associated with.
            "groups": list(),
            "settings": USER_SETTINGS,
            "sessions": [],
            "salt": salt,
            "permissions": {permission: False for permission in virtool.groups.PERMISSIONS},
            "password": password,
            "primary_group": "",
            # Should the user be forced to reset their password on their next login?
            "force_reset": data["force_reset"],
            # A timestamp taken at the last password change.
            "last_password_change": virtool.utils.timestamp(),
            # Should all of the user's sessions be invalidated so that they are forced to login next time they
            # download the client.
            "invalidate_sessions": False
        }

        yield self.insert(new_user)

        return True, None

    @virtool.gen.exposed_method(["modify_options"])
    def remove_user(self, transaction):
        """
        Remove existing user with the id passed in the transaction.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating success and the response returned by the Mongo remove operation or
                 and error message.
        :rtype: tuple

        """
        user = transaction.connection.user
        data = transaction.data

        # Only one user specified by one user id can be removed per call.
        if not isinstance(data["_id"], str):
            # Send an error message to the client and log a warning if the client attempts to remove more than one user
            # in a single call.
            logger.warning("User {} attempted to remove multiple users in a single call".format(user["_id"]))
            return False, dict(message="Can only remove one user per call")

        if data["_id"] == transaction.connection.user["_id"]:
            # Otherwise send an error message to the client and log a warning.
            logger.warning("User {} attempted to remove their own user account".format(user["_id"]))
            return False, dict(message="User cannot remove their own account")

        response = yield super().remove(data["_id"])

        if response["n"] == 0:
            # Fail and log warning if no documents matched the provided document id.
            logger.warning("User {} attempted to remove non-existent user".format(user["_id"]))
            return False, dict(message="User does not exist")

        return True, response

    @virtool.gen.exposed_method([], unprotected=True)
    def change_password(self, transaction):
        """
        Allows a user change their own password. The old password must be passed in the transaction to authorize the
        password change.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating success and an error message or the response from the Mongo update operation
        :rtype: tuple

        """
        data = transaction.data

        # Will evaluate true if the passed username and password are correct.
        valid_credentials = yield self.validate_login(data["_id"], data["old_password"])

        if not valid_credentials:
            return False, dict(message="Invalid credentials")

        # Salt and hash the new password
        salt, password = salt_hash(data["new_password"])

        # Update the user document. Remove all sessions so those clients will have to authenticate with the new
        # password.
        response = yield self.update(data["_id"], {
            "$set": {
                "password": password,
                "sessions": [],
                "invalidate_sessions": False,
                "salt": salt,
                "last_password_change": virtool.utils.timestamp(),
                "force_reset": False
            }
        })

        return True, response

    @virtool.gen.exposed_method(["modify_options"])
    def set_password(self, transaction):
        """
        Used by users with the *modify_options* permission to change other users passwords. The only parameters that
        need to be included in the transaction are the user's id and the new password. This transaction always succeeds.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: ``True`` and the response from the Mongo update operation
        :rtype: tuple

        """
        salt, password = salt_hash(transaction.data["new_password"])

        response = yield self.update(transaction.data["_id"], {
            "$set": {
                "password": password,
                "salt": salt,
                "last_password_change": virtool.utils.timestamp(),
                "invalidate_sessions": True
            }
        })

        if len(response["_ids"]):
            return True, response

        return False, dict(message="User does not exist")

    @virtool.gen.exposed_method(["modify_options"])
    def set_force_reset(self, transaction):
        """
        Used by users with the *modify_options* permission to Set a users password. Can take a "reset" property, which
        when True will force the user to reset their password on next login. To be called by an connection with
        administrative privileges.

        """
        response = yield self.update(transaction.data["_id"], {
            "$set": {
                "force_reset": transaction.data["force_reset"],
                "invalidate_sessions": True
            }
        })

        if response["_ids"] == [transaction.data["_id"]]:
            return True, response

        return False, dict(message="User does not exist")

    @virtool.gen.exposed_method([], unprotected=True)
    def authorize_by_login(self, transaction):
        """
        Authorize a connection by validating a username and password passed in the transaction by calling
        :meth:`.validate_login`. The transaction will fail if the username and password are invalid or if the
        ``force_reset`` flag is set on the user document. The message returned to the client indicates what the cause of
        failure was::

            # Failure due to invalid credentials.
            message = dict(force_reset=False)

            # Failure due to force_reset flag being set on the user. Causes
            # the client to show a change password form.
            message = dict(force_reset=True)

        If the transaction succeeds a new session is created for the user and a stripped down user document is sent to
        the client so it is aware of permissions and settings.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: boolean indicating success and a user document or a failure message.
        :rtype: tuple

        """
        data = transaction.data

        user = yield self.validate_login(data["username"], data["password"])

        if not user:
            return False, dict(message="Incorrect username or password", force_reset=False)

        # Remove expired sessions.
        sessions = list(filter(
            lambda x: x["browser"]["name"] != data["browser"]["name"] and x["ip"] != transaction.connection.ip,
            user["sessions"]
        ))

        token = virtool.utils.random_alphanumeric(24)

        sessions.append({
            "token": token,
            "timestamp": virtool.utils.timestamp(),
            "ip": transaction.connection.ip,
            "browser": data["browser"]
        })

        yield self.update(user["_id"], {
            "$set": {
                "sessions": sessions
            }
        })

        user["token"] = token

        transaction.connection.user = user
        transaction.connection.authorized = not user["force_reset"]

        if user["force_reset"]:
            return False, dict(message="Password must be reset", force_reset=True)

        return True, {key: user[key] for key in [
            "_id",
            "groups",
            "last_password_change",
            "primary_group",
            "permissions",
            "settings",
            "token"
        ]}

    @virtool.gen.exposed_method([], unprotected=True)
    def authorize_by_token(self, transaction):
        """
        Takes a session token and a browser string generated on the client by `bowser <https://github.com/ded/bowser>`_.
        Finds a user with a session matching the given token. For the authorization to succeed, the IP and browser
        type of the session matched by the token must match the requesting IP and the browser type sent by the client.
        Authorization will fail if:

        * the token is not found in any user's sessions
        * the token is found, but the requesting IP doesn't match that of the session
        * the token is found, but the requesting browser doesn't match that of the session.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: boolean indicating success and a user document or a failure message.
        :rtype: tuple

        """
        data = transaction.data

        # Find the user associated with the sessions token (if there is one).
        user = yield self.find_one({
            "sessions.token": data["token"]
        })

        if not user:
            return False, dict(message="Token does not exist")

        # Get the user's session associated with the supplied token.
        session = virtool.utils.where(user["sessions"], lambda x: x["token"] == data["token"])

        # Fail if the token does not match the passed browser and ip.
        if session["ip"] != transaction.connection.ip or session["browser"]["name"] != data["browser"]["name"]:
            return False, dict(message="Token is invalid")

        # If the user has the invalidate sessions flag set, fail authorization and clear all of their sessions. Unset
        # the invalidate_sessions flag since we just did it.
        if user["invalidate_sessions"] and data["token"]:
            yield self.update(user["_id"], {
                "$set": {
                    "sessions": [],
                    "invalidate_sessions": False
                }
            })

            return False, dict(message="Token was invalidated")

        # Get ready to send the token to the client.
        user["token"] = data["token"]

        # Set the connection as authorized and populate the :attr:`.SocketHandler.user` attribute.
        transaction.connection.user = user
        transaction.connection.authorized = True

        # Return ``True`` for success and a stripped down user document so the client has a clue.
        return True, {key: user[key] for key in [
            "_id",
            "groups",
            "last_password_change",
            "primary_group",
            "permissions",
            "settings",
            "token"
        ]}

    @virtool.gen.exposed_method(["modify_options"])
    def remove_session(self, transaction):
        removed = yield self.invalidate_session(transaction.data["token"])

        if not removed:
            return False, dict(message="Session does not exist")

        return True, None

    @virtool.gen.exposed_method([])
    def logout(self, transaction):
        yield self.invalidate_session(
            transaction.connection.user["token"],
            logout=True
        )

        return True, None

    @virtool.gen.coroutine
    def validate_login(self, username, password):
        """
        Returns ``True`` if the username exists and the password is correct. Returns ``False`` if the username does not
        exist or the or the password is incorrect.

        :param username: the username to check.
        :type username: str

        :param password: the password to check.
        :type password: str

        :return: ``True`` if valid, otherwise ``False``.
        :rtype: bool

        """
        user_exists = yield self.user_exists(username)

        # First, check if the user exists in the database. Return False if the user does not exist.
        if user_exists:
            # Retrieve user information from database (username, hashed and salted password, salt)
            user = yield self.find_one({"_id": username})

            # Return True if the attempted password matches the stored password.
            if check_password(password, user["password"], user["salt"]):
                return user

        return False

    @virtool.gen.coroutine
    def invalidate_session(self, token, logout=False):
        """
        Invalidate the session identified by the passed token. Can be called as the result of a logout or a forced
        invalidation by a user with the *modify_options* permission.

        :param token:
        :type token: str

        :param logout: the invalidation is the result of a logout
        :type logout: bool

        :return:
        :rtype: bool

        """
        session_count = yield self.find({"sessions.0.token": token}).count()

        if session_count > 1:
            raise ValueError("Multiple sessions matching token {}".format(token))

        response = yield self.update({"sessions.0.token": token}, {
            "$pull": {
                "sessions": {
                    "token": token
                }
            }
        })

        removed_count = len(response["_ids"])

        if removed_count:
            self._dispatch({
                "operation": "deauthorize",
                "data": {
                    "logout": logout
                }
            }, conn_filter=lambda conn: conn.user["token"] == token)

            return True

        return False

    @virtool.gen.coroutine
    def user_exists(self, user_id):
        """
        Checks if the passed ``user_id`` exists in the database.

        :param user_id: the user id to check for.
        :type user_id: str

        :return: ``True`` if the user exists, ``False`` otherwise.
        :rtype: bool

        """
        user_count = yield self.find({"_id": user_id}).count()

        return bool(user_count)


def salt_hash(password):
    """
    Salt and hash a password. This function is used for generating new salts and salted and hashed passwords for users.

    :param password: the string to salt and hash.
    :type password: str

    :return: a salt and hashed password.
    :rtype: tuple

    """
    salt = virtool.utils.random_alphanumeric(24)

    hashed = hashlib.sha512(salt.encode("utf-8") + password.encode("utf-8")).hexdigest()

    return salt, hashed


def check_password(password, hashed, salt):
    """
    Check if the plain text ``password`` matches the ``hashed_password`` and ``salt``. Returns ``True`` if they match.

    :param password: the plain text password to check.
    :type password: str

    :param hashed: the salted and hashed password from the database
    :type salt: str

    :param salt: the salt to apply to the hashed password
    :type salt: str

    :return: ``True`` if there is a match; ``False`` if not
    :rtype: bool

    """
    return hashed == hashlib.sha512(salt.encode("utf-8") + password.encode("utf-8")).hexdigest()
