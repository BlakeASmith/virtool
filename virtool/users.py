import hashlib
import logging

import virtool.gen
import virtool.database
import virtool.utils
import virtool.groups

logger = logging.getLogger(__name__)


class Collection(virtool.database.Collection):
    """
    Provides an interface to the users MongoDB collection. During initialisation of the object, permissions are
    reconciled for all users and all user documents are updated to contain required fields if they are missing.

    :param dispatcher: the dispatcher that instantiated the collection.
    :type dispatcher: :class:`.Dispatcher`

    """
    def __init__(self, dispatcher):
        super(Collection, self).__init__("users", dispatcher)

        self.sync_projector.update({
            "groups": True,
            "sessions": True,
            "force_reset": True,
            "last_password_change": True,
            "permissions": True,
            "settings": True,
            "primary_group": True
        })

        # Get a synchronous connection to the users collection to do some initial setup.
        db_sync = virtool.utils.get_db_client(self.settings, sync=True)

        # If any users lack the ``primary_group`` field, add it with a value of ``None``.
        db_sync.users.update({"primary_group": {"$exists": False}}, {
            "$set": {"primary_group": None}
        }, multi=True)

        # Assign default user settings to users without defined settings.
        db_sync.users.update({"settings": {}}, {
            "$set": {"settings": {"show_ids": False, "show_versions": False}}
        }, multi=True)

        # Make sure permissions are reconciled for all users.
        for user in db_sync.users.find():
            groups = db_sync.groups.find({"_id": {
                "$in": user["groups"]
            }})

            db_sync.users.update({"_id": user["_id"]}, {
                "$set": {
                    "permissions": reconcile_permissions(list(groups))
                }
            })

    @virtool.gen.coroutine
    def update(self, query, update, increment_version=True, upsert=False, connections=None):
        """
        A redefinition of :meth:`.database.Collection.update` that dispatches an ``amend`` operation with a copy of the
        entire new user document to connections owned by the modified users. The user dict referenced by
        :attr:`.SocketHandler.user` is also updated so permissions can be checked on the server side.

        :param query: query dictionary or single document id to be passed to MongoDB as a query.
        :type query: str or dict

        :param update: the update that will be passed to MongoDB.
        :type update: dict

        :param increment_version: when ``True``, the _version field is incremented by 1.
        :type increment_version: bool

        :param upsert: perform an upsert when set to True.
        :type upsert: bool

        :param connections: a list of :class:`~.web.SocketHandler` objects to dispatch the update to. If no list is
                            supplied, the update with be dispatched to all connected clients.
        :type connections: list or None

        :return: the MongoDB response object amended with the modified document ids.
        :rtype: dict

        """
        response = yield super(Collection, self).update(query, update, increment_version, upsert)

        for connection in self.dispatcher.connections:
            if connection.user["_id"] in response["_ids"]:
                user = yield self.find_one({"_id": connection.user["_id"]})

                connection.user.update(user)

                to_dispatch = {key: connection.user[key] for key in [
                    "_id",
                    "groups",
                    "last_password_change",
                    "primary_group",
                    "permissions",
                    "settings",
                    "token"
                ]}

                yield self.dispatch(
                    "amend",
                    to_dispatch,
                    connections=[connection]
                )

        return response

    @virtool.gen.exposed_method(["modify_options"])
    def set_group(self, transaction):
        """
        Toggle membership for the user identified by the passed user id in the group with the passed group id.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating success and the responses from calling :meth:`.update_user_permissions`.
        :rtype: tuple

        """
        data = transaction.data

        group_ids = yield self.get_field(data["user_id"], "groups")

        if data["group_id"] == "administrator" and data["user_id"] == transaction.connection.user["_id"]:
            return False, dict(message="Administrator cannot remove themselves from the administrator group.")

        if data["group_id"] in group_ids:
            group_ids.remove(data["group_id"])
        else:
            group_ids.append(data["group_id"])

        response = yield self.update_user_permissions(data["user_id"], group_ids)

        return True, response

    @virtool.gen.exposed_method(["modify_options"])
    def set_primary_group(self, transaction):
        """
        Sets the group with the passed group id as the primary group of the user identified by the passed user id.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating success and the response from the Mongo update operation.
        :rtype: tuple

        """
        response = yield self.update(transaction.data["_id"], {"$set": {
            "primary_group": transaction.data["group_id"]
        }})

        return True, response

    @virtool.gen.coroutine
    def update_user_permissions(self, user_ids, group_ids=None):
        """
        Update user permissions when the properties of a group change or when a user is added to or remove from a group.
        If the update is due to a change in the user's group membership, a list of group ids is passed and used to
        update the both the users' groups and permissions.

        :param user_ids: the id or ids of the user or users to update permissions for.
        :type user_ids: list or str

        :param group_ids: a list of groups that should be associated with the user if changing membership.
        :type group_ids: list

        :return: a list of responses from Mongo update.
        :rtype: list

        """
        user_ids = virtool.database.coerce_list(user_ids)

        # Get the affected users.
        users = yield self.find({"_id": {"$in": user_ids}}, {
            "groups": True,
            "permissions": True
        }).to_list(None)

        groups = None

        if group_ids is not None:
            groups = yield self.dispatcher.collections["groups"].find({
                "_id": {
                    "$in": virtool.database.coerce_list(group_ids)
                }
            }).to_list(None)

        responses = list()

        for user in users:
            # If a new list of group_ids is passed set these as the user's new groups. A list of group documents has
            # already been defined above.
            try:
                own_groups = list(groups)
            except TypeError:
                own_groups = yield self.dispatcher.collections["groups"].find({
                    "_id": {
                        "$in": user["groups"]
                    }
                }).to_list(None)
            else:
                user["groups"] = group_ids

            user["permissions"] = yield virtool.gen.THREAD_POOL.submit(reconcile_permissions, own_groups)

            user_id = user.pop("_id")

            response = yield self.update(user_id, {"$set": user})

            responses.append(response)

        return responses

    @virtool.gen.exposed_method([])
    def change_user_setting(self, transaction):
        """
        Change the user settings identified by the ``key`` passed in the transaction to the ``value`` passed in the
        transaction.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating success and an error message or the response from the Mongo update operation
        :rtype: tuple

        """
        user = transaction.connection.user
        data = transaction.data

        if data["_id"] == user["_id"]:
            response = yield self.update(data["_id"], {"$set": {
                "settings." + data["key"]: data["value"]
            }}, transaction)

            return True, response

        return False, dict(message="Must be user account holder to change settings.")

    @virtool.gen.exposed_method(["modify_options"])
    def add(self, transaction):
        """
        Add a new user to the user database. The transaction should pass a new username (_id), a password, and the key
        ``force_reset`` set to ``True`` or ``False``. Setting ``force_reset`` will make the user reset their password
        the first time they login.

        The transaction will not succeed if the user id already exists.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating success and either an error message or the Mongo insert response.
        :rtype: tuple

        """
        data = transaction.data

        # Check if the username is already taken. Fail if it does.
        user_exists = yield self.user_exists(data["_id"])

        if user_exists:
            return False, dict(message="User already exists.")

        salt, password = salt_hash(data["password"])

        new_user = {
            "_id": data["_id"],
            # A list of group _ids the user is associated with.
            "groups": list(),
            "settings": {},
            "sessions": [],
            "salt": salt,
            "permissions": {permission: False for permission in virtool.groups.PERMISSIONS},
            "password": password,
            "primary_group": None,
            # Should the user be forced to reset their password on their next login?
            "force_reset": data["force_reset"],
            # A timestamp taken at the last password change.
            "last_password_change": virtool.utils.timestamp(),
            # Should all of the user's sessions be invalidated so that they are forced to login next time they
            # download the client.
            "invalidate_sessions": False
        }

        response = yield self.insert(new_user)

        return True, response

    @virtool.gen.exposed_method(["modify_options"])
    def remove_user(self, transaction):
        """
        Remove existing user with the id passed in the transaction.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating success and the response returned by the Mongo remove operation or
                 and error message.
        :rtype: tuple

        """
        user = transaction.connection.user
        data = transaction.data

        # Only one user specified by one user id can be removed per call.
        if not isinstance(data["_id"], str):
            # Send an error message to the client and log a warning if the client attempts to remove more than one user
            # in a single call.
            logger.warning("User {} attempted to remove multiple users in a single call".format(user["_id"]))
            return False, dict(message="Can only remove one user per call")

        if not self.user_exists(data["_id"]):
            # Otherwise send an error message to the client and log a warning.
            logger.warning("User {} attempted to remove non-existent user".format(user["_id"]))
            return False, dict(message="User does not exist.")

        if data["_id"] == transaction.connection.user["_id"]:
            # Otherwise send an error message to the client and log a warning.
            logger.warning("User {} attempted to remove their own user account".format(user["_id"]))
            return False, dict(message="User cannot remove their own account.")

        response = yield super(Collection, self).remove(data["_id"])

        return True, response

    @virtool.gen.exposed_method([], unprotected=True)
    def change_password(self, transaction):
        """
        Allows a user change their own password. The old password must be passed in the transaction to authorize the
        password change.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: a boolean indicating success and an error message or the response from the Mongo update operation
        :rtype: tuple

        """
        data = transaction.data

        # Will evaluate true if the passed username and password are correct.
        valid_credentials = yield self.validate_login(data["_id"], data["old_password"])

        if not valid_credentials:
            return False, dict(message="Credentials are invalid.")

        # Salt and hash the new password
        salt, password = salt_hash(data["new_password"])

        # Update the user document. Remove all sessions so those clients will have to authenticate with the new
        # password.
        response = yield self.update(data["_id"], {
            "$set": {
                "password": password,
                "sessions": [],
                "invalidate_sessions": False,
                "salt": salt,
                "last_password_change": virtool.utils.timestamp(),
                "force_reset": False
            }
        })

        return True, response

    @virtool.gen.exposed_method(["modify_options"])
    def set_password(self, transaction):
        """
        Used by users with the *modify_options* permission to change other users passwords. The only parameters that
        need to be included in the transaction are the user's id and the new password. This transaction always succeeds.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: ``True`` and the response from the Mongo update operation
        :rtype: tuple

        """
        salt, password = salt_hash(transaction.data["new_password"])

        response = yield self.update(transaction.data["_id"], {
            "$set": {
                "password": password,
                "salt": salt,
                "last_password_change": virtool.utils.timestamp(),
                "invalidate_sessions": True
            }
        })

        return True, response

    @virtool.gen.exposed_method(["modify_options"])
    def set_force_reset(self, transaction):
        """
        Used by users with the *modify_options* permission to Set a users password. Can take a "reset" property, which
        when True will force the user to reset their password on next login. To be called by an connection with
        administrative privileges.

        """
        response = yield self.update(transaction.data["_id"], {
            "$set": {
                "force_reset": transaction.data["force_reset"],
                "invalidate_sessions": True
            }
        })

        return True, response

    @virtool.gen.exposed_method([], unprotected=True)
    def authorize_by_login(self, transaction):
        """
        Authorize a connection by validating a username and password passed in the transaction by calling
        :meth:`.validate_login`. The transaction will fail if the username and password are invalid or if the
        ``force_reset`` flag is set on the user document. The message returned to the client indicates what the cause of
        failure was::

            # Failure due to invalid credentials.
            message = dict(force_reset=False)

            # Failure due to force_reset flag being set on the user. Causes
            # the client to show a change password form.
            message = dict(force_reset=True)

        If the transaction succeeds a new session is created for the user and a stripped down user document is sent to
        the client so it is aware of permissions and settings.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: boolean indicating success and a user document or a failure message.
        :rtype: tuple

        """
        data = transaction.data

        user = yield self.validate_login(data["username"], data["password"])

        if not user:
            return False, dict(force_reset=False)

        # Remove expired sessions.
        sessions = list(filter(
            lambda x: x["browser"] == data["browser"] and x["ip"] == transaction.connection.ip,
            user["sessions"]
        ))

        token = virtool.utils.random_alphanumeric(24)

        sessions.append({
            "token": token,
            "timestamp": virtool.utils.timestamp(),
            "ip": transaction.connection.ip,
            "browser": data["browser"]
        })

        yield self.update(user["_id"], {
            "$set": {
                "sessions": sessions
            }
        })

        user["token"] = token

        transaction.connection.user = user
        transaction.connection.authorized = not user["force_reset"]

        if user["force_reset"]:
            return False, dict(force_reset=True)

        return True, {key: user[key] for key in [
            "_id",
            "groups",
            "last_password_change",
            "primary_group",
            "permissions",
            "settings",
            "token"
        ]}

    @virtool.gen.exposed_method([], unprotected=True)
    def authorize_by_token(self, transaction):
        """
        Takes a session token and a browser string generated on the client by `bowser <https://github.com/ded/bowser>`_.
        Finds a user with a session matching the given token. For the authorization to succeed, the IP and browser
        type of the session matched by the token must match the requesting IP and the browser type sent by the client.
        Authorization will fail if:

        * the token is not found in any user's sessions
        * the token is found, but the requesting IP doesn't match that of the session
        * the token is found, but the requesting browser doesn't match that of the session.

        :param transaction: the transaction generated by the request.
        :type transaction: :class:`.Transaction`

        :return: boolean indicating success and a user document or a failure message.
        :rtype: tuple

        """
        data = transaction.data

        # Find the user associated with the sessions token (if there is one).
        user = yield self.find_one({
            "sessions.token": data["token"]
        })

        # Fail authorization if no user if found for the token.
        if not user:
            return False, None

        # Get the user's session associated with the supplied token.
        session = virtool.utils.where(user["sessions"], lambda x: x["token"] == data["token"])

        # Make sure the token matches the passed browser and ip. Fail otherwise.
        if session["ip"] != transaction.connection.ip or session["browser"] != data["browser"]:
            return False, None

        # If the user has the invalidate sessions flag set, fail authorization and clear all of their sessions. Unset
        # the invalidate_sessions flag since we just did it.
        if user["invalidate_sessions"] and data["token"]:
            yield self.update(user["_id"], {
                "$set": {
                    "sessions": [],
                    "invalidate_sessions": False
                }
            })

            return False, None

        # Get ready to send the token to the client.
        user["token"] = data["token"]

        # Set the connection as authorized and populate the :attr:`.SocketHandler.user` attribute.
        transaction.connection.user = user
        transaction.connection.authorized = True

        # Return ``True`` for success and a stripped down user document so the client has a clue.
        return True, {key: user[key] for key in [
            "_id",
            "groups",
            "last_password_change",
            "primary_group",
            "permissions",
            "settings",
            "token"
        ]}

    @virtool.gen.coroutine
    def validate_login(self, username, password):
        """
        Returns ``True`` if the username exists and the password is correct. Returns ``False`` if the username does not
        exist or the or the password is incorrect.

        :param username: the username to check.
        :type username: str

        :param password: the password to check.
        :type password: str

        :return: ``True`` if valid, otherwise ``False``.
        :rtype: bool

        """
        user_exists = yield self.user_exists(username)

        # First, check if the user exists in the database. Return False if the user does not exist.
        if user_exists:
            # Retrieve user information from database (username, hashed and salted password, salt)
            user = yield self.find_one({"_id": username})

            # Salt and hash attempted password
            _, attempted_password = salt_hash(password, salt=user["salt"])

            # Return True if the attempted password matches the stored password.
            if attempted_password == user["password"]:
                return user

        return False

    @virtool.gen.exposed_method(["modify_options"])
    def remove_session(self, transaction):
        yield self.invalidate_session(transaction.data["token"])

        return True, None

    @virtool.gen.exposed_method([])
    def logout(self, transaction):
        if transaction.data["token"] == transaction.connection.user["token"]:
            yield self.invalidate_session(
                transaction.data["token"],
                logout=True
            )

            return True, None

        return False, None

    @virtool.gen.coroutine
    def invalidate_session(self, token, logout=False):
        """
        Invalidate the session identified by the passed token. Can be called as the result of a logout or a forced
        invalidation by a user with the *modify_options* permission.

        :param token:
        :type token: str

        :param logout: the invalidation is the result of a logout
        :type logout: bool

        :return:
        :rtype: bool

        """
        connections = [connection for connection in self.dispatcher.connections if connection.user["token"] == token]

        assert len(connections) <= 1

        yield self.update({"sessions.0.token": token}, {
            "$pull": {
                "sessions": {
                    "token": token
                }
            }
        })

        if connections:
            self.dispatcher.dispatch({
                "operation": "deauthorize",
                "data": {"logout": logout}
            }, connections)

    @virtool.gen.coroutine
    def user_exists(self, user_id):
        """
        Checks if the passed ``user_id`` exists in the database.

        :param user_id: the user id to check for.
        :type user_id: str

        :return: ``True`` if the user exists, ``False`` otherwise.
        :rtype: bool

        """
        user_count = yield self.find({"_id": user_id}).count()

        return bool(user_count)


def salt_hash(password, salt=None):
    """
    Salt and hash a password. This function is used for generating new salts and salted and hashed passwords for users.
    If the ``salt`` argument is not assigned, it is assumed we are generating a new salt and hashed password.

    .. code-block:: pycon

        >>> salt, hashed = salt_hash("grapevine")
        >>> print(salt)
        '02166953ca2d0fc5286d6a39'
        >>> print(hashed)
        '91338439af0d048f2e5ae3253c5003c43a6a0874dce711fbe563b5efb9eba958c598e89b8f90fdd05295c1b22984aac96aa2a114e3adead8f6231d1b463d161c'

    If ``salt`` is not assigned, it will concatenated to the passed ``password`` and the result will be hashed. This is
    used to compare submitted login passwords to the salted and hashed password in the database.

    .. code-block:: pycon

        >>> salt_from_db = '02166953ca2d0fc5286d6a39'
        >>> hashed_from_db = '91338439af0d048f2e5ae3253c5003c43a6a0874dce711fbe563b5efb9eba958c598e89b8f90fdd05295c1b22984aac96aa2a114e3adead8f6231d1b463d161c'
        >>> salt, hashed = salt_hash("grapevine", salt=salt_from_db)
        >>> print(hashed)
        '91338439af0d048f2e5ae3253c5003c43a6a0874dce711fbe563b5efb9eba958c598e89b8f90fdd05295c1b22984aac96aa2a114e3adead8f6231d1b463d161c'
        >>> hashed == hashed_from_db
        True

    :param password: the string to salt and hash.
    :type password: str

    :param salt: the salt to apply to the password if we are checking a password
    :type salt: str

    :return: a salt and hashed password.
    :rtype: tuple

    """
    # If salt is not provided, a new password hash is being generated, so make a new salt string
    salt = salt or virtool.utils.random_alphanumeric(24)

    # Hash the password prepended with salt
    hashed = hashlib.sha512(salt.encode("utf-8") + password.encode("utf-8")).hexdigest()

    # Return a dict of the salt and the hashed password + salt
    return salt, hashed


def reconcile_permissions(groups):
    """
    Return a :class:`dict` of permissions that will be inherited by a user belonging to all the passed ``groups``.

    :param groups: a list of group documents.
    :return: a dict keyed by permission names with boolean values indicating the state of the permission

    """
    permission_dict = {permission_name: False for permission_name in virtool.groups.PERMISSIONS}

    for permission_name in virtool.groups.PERMISSIONS:
        for group in groups:
            if group["permissions"][permission_name]:
                permission_dict[permission_name] = True

    return permission_dict
